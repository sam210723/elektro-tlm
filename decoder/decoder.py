import socket
import collections
from matplotlib import pyplot as plt

SYNC = 0x1ACFFC1D
SYNC_LEN = 32
FRAME_LEN = 224

def init():
    # Setup UDP socket
    global sck
    sck = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sck.bind(("127.0.0.1", 52001))
    print("Waiting for frames...\n")

    # TEST BUFFERS
    #rxbuf = b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x33\x33\x06\xD9\x1A\xCF\xFC\x1D\x33\xF7\x7D\x57\x25\x25\xD4\xF5\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00' # Normal
    #rxbuf = b'\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xCC\xCC\xF9\x26\xE5\x30\x03\xE2\xCC\x08\x82\xA8\xDA\xDA\x2B\x0A\x9F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF' # Inverted
    #rxbuf = b'\x00\x00\x00\x00\x00\x00\x00\x33\x33\x06\xD9\xD6\x7F\xE0\xE8\x33\xF7\x7D\x57\x25\x25\xD4\xF5\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00' # Normal << 3

    # Fill RX buffer then find sync word location and symbol phase
    rxbuf = sck.recv(FRAME_LEN)
    offset, inverted = correlate(rxbuf, SYNC)
    print(f"OFFSET:     {offset}")
    print(f"INVERTED:   {inverted}\n")

    # Trim receive buffer to byte with highest correlation
    rxbuf = rxbuf[offset:]

    plt.show()


def correlate(buffer, sync_p):
    """
    Find position in buffer with highest correlation to sync word

    Args:
        buffer (bytes): Buffer to search
        word (bytes): Sync word to search for

    Returns:
        int: Byte position with highest correlation
        bool: Phase invert flag
    """

    # Get inverted sync word
    sync_n = invert_int(sync_p, SYNC_LEN)
    print(f"SYNC   0°   {to_hex(sync_p)}\nSYNC 180°   {to_hex(sync_n)}")

    # Convert sync word bits to 0x00 and 0xFF
    sync_p_soft = bytearray(SYNC_LEN)
    sync_n_soft = bytearray(SYNC_LEN)
    for i in range(SYNC_LEN):
        sync_p_soft[i] = 0xFF if ((sync_p >> (SYNC_LEN - i - 1)) & 1) else 0x00
        sync_n_soft[i] = 0xFF if ((sync_n >> (SYNC_LEN - i - 1)) & 1) else 0x00

    # Correlation values for each sync word
    corr_p = []
    corr_n = []

    # Loop through frame buffer
    for i in range(len(buffer) - SYNC_LEN):
        p = 0
        n = 0
        
        # Loop through sync word bits
        for j in range(SYNC_LEN):
            p += ((buffer[i+j] >= 127) & (sync_p_soft[j] == 0x00)) | ((buffer[i+j] < 127) & (sync_p_soft[j] == 0xFF))
            n += ((buffer[i+j] >= 127) & (sync_n_soft[j] == 0x00)) | ((buffer[i+j] < 127) & (sync_n_soft[j] == 0xFF))
        
        # Append correlation values to list
        corr_p.append(p)
        corr_n.append(n)

    # Plot correlation values
    plt.plot(corr_p)
    plt.plot(corr_n)
    plt.title("CCSDS Sync Word (0x1ACFFC1D) Correlation")
    plt.xlabel("Offset")
    plt.ylabel("Correlation")
    #plt.show()

    p_max = max(corr_p)
    n_max = max(corr_n)

    if p_max > n_max:
        invert = False
        offset = corr_p.index(p_max)
    else:
        invert = True
        offset = corr_n.index(n_max)

    # Trim buffer to byte with highest correlation
    buffer = buffer[offset:]

    # Convert offset to bits
    offset *= 8

    # Find bit offset of sync word within higest correlation byte
    for i in range(4):
        shifted = shift_bytes(buffer, i)
        syncword = int.from_bytes(shifted[0:4], 'big')
        
        # Invert receive buffer if needed
        if invert: buffer = invert_bytes(buffer)

        print(to_hex(shifted[:8]))
        
        if syncword == sync_p:
            offset += i
            return (offset, invert)
    
    return (None, None)


def shift_bytes(data, n):
    """
    Shift bytes by n bits

    Args:
        data (bytes): Bytes to shift
        n (int): Number of bits so shift bytes
    """

    l = len(data)

    i = int.from_bytes(data, byteorder='big')
    i = i >> n

    return int.to_bytes(i, byteorder='big', length=l)

def invert_int(value, count=8):
    return (1 << count) - 1 - value

def invert_bytes(data):
    data = bytearray(data)

    for i, b in enumerate(data):
        data[i] = 0xFF & ~b
    
    return bytes(data)

def to_hex(data):
    if type(data) == bytes:
        data = int.from_bytes(data, byteorder='big')
    
    h = hex(data).upper()
    s = "0x{}".format(h[2:])

    return s


try:
    init()
except KeyboardInterrupt:
    print("Exiting...")
    exit()
